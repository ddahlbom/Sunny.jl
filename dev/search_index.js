var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, you will need an installation of Julia.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Our package is not yet uploaded to Julia's central package repository, and so you will need to perform more of a \"manual\" installation of our package.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To do this, open a terminal and navigate to the directory where you'd like the package to reside. This does not need to  be where you want to do development of scripts / code that uses the package. Then, clone our repo using:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/MagSims/FastDipole.git","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This will prompt you for your Github username/password to access the code.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"After downloading, open a Julia REPL in the same directory, press ] to access the package manager interface, then add .:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add .","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you'd like to modify/develop the package further, replace the second command with","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(@v1.6) pkg> dev .","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"which will make it so that all modification to the local code will be reflected when the package is loaded.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If no errors appear, you are done! However, to ensure that our plotting dependencies have installed correctly, it is recommended to explicitly add GLMakie to your enviroment and run their tests:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add GLMakie\n(@v1.6) pkg> test GLMakie","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"It is also recommended to explicitly add StaticArrays and OffsetArrays to your enviroment, as our package often accepts and returns types from these packages.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add StaticArrays\n(@v1.6) pkg> add OffsetArrays","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, head over to Examples to start performing your first simulations!","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Here, we document all publically exposed types and methods in our Module. Developers may be interested is further documentation of the Internals.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Our package makes extensive usage of StaticArrays.jl. In particular, throughout the documentation we make use of aliases Vec3 = SVector{3, Float64}, Mat3 = SMatrix{3, 3, Float64, 9}. Additionally, some features and internals utilize OffsetArrays.jl for pleasant interfaces.","category":"page"},{"location":"library/#Geometry-definition","page":"Library","title":"Geometry definition","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Crystal\nCrystal(::SMatrix{3, 3, Float64, 9}, ::Vector{SVector{3, Float64}}, ::Vector{String}; symprec)\nCrystal(::Lattice{3, 9, 4})\nCrystal(::AbstractString; symprec)\nsubcrystal\nLattice\nLattice{D}(lat_vecs, basis_vecs, species, latsize) where {D}\nvolume\neachcellindex\ngen_reciprocal\nlattice_vectors\nlattice_params","category":"page"},{"location":"library/#FastDipole.Symmetry.Crystal","page":"Library","title":"FastDipole.Symmetry.Crystal","text":"Crystal\n\nA type holding all geometry and symmetry information needed to represent  a three-dimensional crystal.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Symmetry.Crystal-Tuple{Lattice{3, 9, 4}}","page":"Library","title":"FastDipole.Symmetry.Crystal","text":"Crystal(lattice::Lattice)\n\nConstruct a Crystal using geometry information in lattice, inferring symmetry information.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.Symmetry.Crystal-Tuple{AbstractString}","page":"Library","title":"FastDipole.Symmetry.Crystal","text":"Crystal(filename::AbstractString; symprec=1e-5)\n\nParse a Crystal from a .cif file located at the path of filename.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.Symmetry.subcrystal","page":"Library","title":"FastDipole.Symmetry.subcrystal","text":"subcrystal(cryst, species) :: Crystal\n\nFilter sublattices of a Crystal by species, keeping the symmetry group of the original Crystal.\n\n\n\n\n\nsubcrystal(cryst, equiv_idxs) :: Crystal\n\nFilter sublattices of a Crystal by a list of indexes into cryst.equiv_atoms,  keeping the symmetry group of the original Crystal.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.Lattice","page":"Library","title":"FastDipole.Lattice","text":"Lattice{D, L, Db}\n\nA type holding geometry information about a lattice in a simulation box. The type parameter D represents the dimensionality of the Lattice,  while the others must satisfy L = D^2, Db = D + 1.\n\nThese other type parameters must be in the definition for technical reasons,  but are inferred without needing them explicitly provided. For example,  see the Lattice{D} constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Lattice-Union{Tuple{D}, NTuple{4, Any}} where D","page":"Library","title":"FastDipole.Lattice","text":"Lattice{D}(lat_vecs, basis_vecs, species, latsize)\n\nConstruct a D-dimensional Lattice.\n\nArguments\n\nlat_vecs: A matrix where the lattice vectors form the columns.             Must be convert-able into SMatrix{D, D, Float64, D^2}.\nbasis_vecs: A Vector of basis positions of sites within the unit cell,                given in fractional coordinates.               Each element must be convert-able into SVector{D, Float64}.\nspecies::Vector{String}: A list of atomic species identifiers for each site.                            Equivalent sites should have the same identifier.\nlatsize: Specifies the number of unit cells extending along each lattice vector.            Must be convert-able into SVector{D, Int}.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.volume","page":"Library","title":"FastDipole.volume","text":"Compute the volume of the full simulation box.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.eachcellindex","page":"Library","title":"FastDipole.eachcellindex","text":"Produce an iterator over all unit cell indices.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.gen_reciprocal","page":"Library","title":"FastDipole.gen_reciprocal","text":"Generate a ReciprocalLattice for a given Lattice\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.lattice_vectors","page":"Library","title":"FastDipole.lattice_vectors","text":"lattice_vectors(a, b, c, Î±, Î², Î³) :: Mat3\n\nCompute a set of lattice vectors (forming the columns of the result), specified by a given  set of lattice parameters (a b c Î± Î² Î³).\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.lattice_params","page":"Library","title":"FastDipole.lattice_params","text":"lattice_params(lat_vecs::Mat3)\n\nCompute the lattice parameters (a b c Î± Î² Î³) from a set of lattice vectors,  which form the columns of lat_vecs.\n\n\n\n\n\nlattice_params(lattice::Lattice{3})\n\n\n\n\n\n","category":"function"},{"location":"library/#Symmetry-analysis","page":"Library","title":"Symmetry analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Bond\nallowed_J\nprint_bond_table\nall_symmetry_related_bonds\nall_symmetry_related_interactions","category":"page"},{"location":"library/#FastDipole.Symmetry.Bond","page":"Library","title":"FastDipole.Symmetry.Bond","text":"Bond{D}\n\nRepresents a class of bond between pairs of sites in a D-dimensional crystal,  separated from each other by a certain vector.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Symmetry.allowed_J","page":"Library","title":"FastDipole.Symmetry.allowed_J","text":"allowed_J(cryst::Crystal, b::Bond{3}; digits=2, tol=1e-4)\n\nGiven a bond b, returns a Matrix{String} representing the allowed  form of a bilinear exchange interaction matrix on this bond, given the  symmetry constraints of cryst.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.Symmetry.print_bond_table","page":"Library","title":"FastDipole.Symmetry.print_bond_table","text":"print_bond_table(cryst::Crystal, max_dist)\n\nPretty-prints a table of all symmetry classes of bonds present in cryst, up  to a maximum bond length of max_dist in absolute coordinates. For each class,  a single \"canonical\" bond is shown, with i, j being the two sublattices  connected, and n being the displacement vector in units of the lattice vectors.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.Symmetry.all_symmetry_related_bonds","page":"Library","title":"FastDipole.Symmetry.all_symmetry_related_bonds","text":"all_symmetry_related_bonds(cryst::Crystal, b_ref::Bond{3}) :: Vector{Bond{3}}\n\nConstruct a list of all bonds which are symmetry-equivalent to the reference bond b_ref  within `cryst.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.Symmetry.all_symmetry_related_interactions","page":"Library","title":"FastDipole.Symmetry.all_symmetry_related_interactions","text":"all_symmetry_related_interactions(cryst::Crystal, b_ref::Bond{3}, J_ref::Mat3) :: Tuple{Vector{Bond3}, Vector{Mat3}}\n\nGiven a reference bond b_ref and exchange matrix J_ref on that bond, construct lists of all  symmetry-equivalent bonds and their respective transformed exchange matrices.\n\n\n\n\n\n","category":"function"},{"location":"library/#Interactions","page":"Library","title":"Interactions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ExternalField\nOnSite\nHeisenberg\nHeisenberg(::Float64, ::Crystal, ::Bond, ::String)\nDiagonalCoupling\nDiagonalCoupling(::SVector{3, Float64}, ::Crystal, ::Bond, ::String)\nGeneralCoupling\nGeneralCoupling(::SMatrix{3, 3, Float64, 9}, ::Crystal, ::Bond, ::String)\nDipoleReal\nDipoleFourier\nHamiltonian\nHamiltonian(ints)","category":"page"},{"location":"library/#FastDipole.ExternalField","page":"Library","title":"FastDipole.ExternalField","text":"ExternalField(B::Vec3)\n\nDefines an external field acting on each spin, specifically the term\n\n    -_i ð  ð’_i\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.OnSite","page":"Library","title":"FastDipole.OnSite","text":"OnSite(J::Vec3, label=\"OnSite\")\n\nConstruct an on-site anisotropy term specified by the vector J. Specifically, the term\n\n    _i _Î± J_Î± S_i Î±^2\n\nEquivalent to DiagonalCoupling with bonds = [(0,0,0)], but faster.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Heisenberg","page":"Library","title":"FastDipole.Heisenberg","text":"Heisenberg{D}\n\nDefines a Heisenberg interaction on a D-dimensional lattice. Specifically, the term\n\n    J _ij ð’_i  ð’_j \n\nwhere ij indicates a sum over all bonds in the lattice of a certain symmetry equivalence class, with each bond appearing only once.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Heisenberg-Tuple{Float64, Crystal, Bond, String}","page":"Library","title":"FastDipole.Heisenberg","text":"Heisenberg(J::Float64, cryst::Crystal, bond::Bond{D}, label=\"Heisenberg\")\n\nConstruct a Heisenberg{D} interaction of strength J acting on all bonds symmetry-equivalent to bond in cryst.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.DiagonalCoupling","page":"Library","title":"FastDipole.DiagonalCoupling","text":"DiagonalCoupling{D}\n\nDefines a diagonal exchange interaction on a D-dimensional lattice. Specifically, the term\n\n    _ij _Î± J_Î± S_iÎ±  S_jÎ± \n\nwhere ij indicates a sum over all bonds in the lattice of a certain symmetry equivalence class, with each bond appearing only once.\n\nWarning: This type currently (and incorrectly) assumes that ð‰ takes the same form on every bond within the equivalency class.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.DiagonalCoupling-Tuple{SVector{3, Float64}, Crystal, Bond, String}","page":"Library","title":"FastDipole.DiagonalCoupling","text":"DiagonalCoupling(J::Vec3, cryst::Crystal, bond::Bond{D}, label=\"Heisenberg\")\n\nConstruct a DiagonalCoupling{D} interaction with diagonal elements specified by J, acting on all bonds symmetry-equivalent to bond in cryst.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.GeneralCoupling","page":"Library","title":"FastDipole.GeneralCoupling","text":"GeneralCoupling{D}\n\nDefines a general exchange interaction on a D-dimensional lattice. Specifically, the term\n\n    _ij ð’_i^ J ð’_j\n\nwhere ij indicates a sum over all bonds in the lattice of a certain symmetry equivalence class, with each bond appearing only once. J is a 3  3 matrix which may vary from bond to bond, under symmetry constraints.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.GeneralCoupling-Tuple{SMatrix{3, 3, Float64, 9}, Crystal, Bond, String}","page":"Library","title":"FastDipole.GeneralCoupling","text":"GeneralCoupling(J::Mat3, cryst::Crystal, bond::Bond{D}, label=\"GenJ\")\n\nConstruct a GeneralCoupling{D} interaction specified by the J matrix  on the given bond in cryst. Automatically propagates the correctly  transformed exchange matrices to all symmetry-equivalent bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.DipoleReal","page":"Library","title":"FastDipole.DipoleReal","text":"Dipole-dipole interactions computed in real-space. DipoleFourier should be preferred in actual simulations, but this type persists as a cross-check to test the Fourier-space calculations.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.DipoleFourier","page":"Library","title":"FastDipole.DipoleFourier","text":"Dipole-dipole interactions computed in Fourier-space. Should produce identical results (up to numerical precision) as DipoleReal, but is asymptotically faster.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Hamiltonian","page":"Library","title":"FastDipole.Hamiltonian","text":"Hamiltonian{D}\n\nDefines a Hamiltonian for a D-dimensional spin system.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.Hamiltonian-Tuple{Any}","page":"Library","title":"FastDipole.Hamiltonian","text":"Hamiltonian{D}(ints)\nHamiltonian{D}(ints...)\n\nConstruct a Hamiltonian{D} from a list of Interaction's.\n\n\n\n\n\n","category":"method"},{"location":"library/#System-definition","page":"Library","title":"System definition","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ChargeSystem\nChargeSystem(::Lattice)\nrand!(::ChargeSystem)\nSpinSystem\nSpinSystem(::Lattice{D}, ::Hamiltonian{D}, ::Rational{Int}) where {D}\nrand!(::SpinSystem)\nenergy","category":"page"},{"location":"library/#FastDipole.ChargeSystem","page":"Library","title":"FastDipole.ChargeSystem","text":"Defines a collection of charges. Currently primarily used to test ewald  summation calculations.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.ChargeSystem-Tuple{Lattice}","page":"Library","title":"FastDipole.ChargeSystem","text":"ChargeSystem(lat::Lattice)\n\nConstruct a ChargeSystem on the given lattice, initialized to all zero charges.\n\n\n\n\n\n","category":"method"},{"location":"library/#Random.rand!-Tuple{ChargeSystem}","page":"Library","title":"Random.rand!","text":"rand!(sys::ChargeSystem)\n\nSets charges to random values uniformly drawn from -1 1, then shifted to charge-neutrality.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.SpinSystem","page":"Library","title":"FastDipole.SpinSystem","text":"Defines a collection of spins, as well as the Hamiltonian they interact under.  This is the main type to interface with most of the package.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.SpinSystem-Union{Tuple{D}, Tuple{Lattice{D, L, Db} where {L, Db}, Hamiltonian{D}, Rational{Int64}}} where D","page":"Library","title":"FastDipole.SpinSystem","text":"SpinSystem(lattice::Lattice, â„‹::Hamiltonian, S=1//1)\n\nConstruct a SpinSystem with spins of magnitude S residing on the given lattice,  and interactions given by â„‹. Initialized to all spins pointing along  the +ð³ direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Random.rand!-Tuple{SpinSystem}","page":"Library","title":"Random.rand!","text":"rand!(sys::SpinSystem)\n\nSets spins randomly sampled on the unit sphere.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.energy","page":"Library","title":"FastDipole.energy","text":"energy(sys::SpinSystem)\n\nComputes the energy of the system under sys.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#Sampling","page":"Library","title":"Sampling","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"LangevinSampler(::SpinSystem, ::Float64, ::Float64, ::Float64, ::Int)\nMetropolisSampler\nset_temp!\nsample!\nthermalize!\nanneal!","category":"page"},{"location":"library/#FastDipole.LangevinSampler-Tuple{SpinSystem, Float64, Float64, Float64, Int64}","page":"Library","title":"FastDipole.LangevinSampler","text":"LangevinSampler(sys, kT, Î±, Î”t, nsteps)\n\nCreates a LangevinSampler which samples the spin system's Hamiltonian using Langevin  dynamics at a temperature kT, damping coefficient Î±, and producing a new sample  by integrating with nsteps timesteps of size Î”t.\n\n\n\n\n\n","category":"method"},{"location":"library/#FastDipole.MetropolisSampler","page":"Library","title":"FastDipole.MetropolisSampler","text":"MetropolisSampler(sys::SpinSystem, kT::Float64, nsweeps::Int)\n\nA sampler which performs the standard Metropolis Monte Carlo algorithm to  sample a SpinSystem at the requested temperature.\n\nEach single-spin update attempts to move the spin to a random position on  the unit sphere. One call to sample! will attempt to flip each spin  nsweeps times.\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.set_temp!","page":"Library","title":"FastDipole.set_temp!","text":"set_temp!(sampler, kT)\n\nChanges the temperature of the sampler to kT.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.sample!","page":"Library","title":"FastDipole.sample!","text":"sample!(sampler)\n\nSamples sampler.system to a new state, under the Boltzmann distribution  as defined by sampler.system.hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.thermalize!","page":"Library","title":"FastDipole.thermalize!","text":"thermalize!(sampler, num_samples)\n\nsample! a sampler a given number of times.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.anneal!","page":"Library","title":"FastDipole.anneal!","text":"anneal!(sampler, temp_schedule, step_schedule)\n\nsample! a sampler at a series of temperatures, staying at each temperature   for the number of steps in step_schedule.\n\n\n\n\n\nanneal!(sampler, temp_function, num_samples)\n\nsample! a sampler num_samples times, with the sample at timestep n  drawn at a temperature temp_function(n).\n\n\n\n\n\n","category":"function"},{"location":"library/#Structure-factor-calculations","page":"Library","title":"Structure factor calculations","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"structure_factor\ndipole_factor","category":"page"},{"location":"library/#FastDipole.structure_factor","page":"Library","title":"FastDipole.structure_factor","text":"structure_factor(sys, sampler; num_samples, dynÎ”t, meas_rate, num_meas\n                                bz_size, therm_samples, verbose)\n\nMeasures the full structure factor tensor of a spin system, for the requested range of ðª-space. Returns ð’®^Î±Î²(ðª Ï‰) = S^Î±(ðª Ï‰) S^Î²(ðª Ï‰)^, which is an array of shape     [3, 3, Q1, ..., Qd, T] where Qi = max(1, bz_size_i * L_i)\n\nnum_samples sets the number of thermodynamic samples to measure and average  across from sampler. dynÎ”t sets the integrator timestep during dynamics,  and meas_rate sets how often snapshots are recorded during dynamics. The sampler  is sampled therm_samples times before any measurements are made.\n\nThe maximum frequency sampled is Ï‰max = 2Ï€ / (dynÎ”t * meas_rate), and the frequency resolution  is set by num_meas (the number of spin snapshots measured during dynamics).\n\nIndexing the result at (Î±, Î², q1, ..., qd, w) gives S^Î±Î²(ðª Ï‰) at     ðª = q1 * aâƒ° + q2 * bâƒ° + q3 * câƒ°, and Ï‰ = maxÏ‰ * w / T, where aâƒ°, bâƒ°, câƒ°     are the reciprocal lattice vectors of sys.lattice.\n\nAllowed values for the qi indices lie in -div(Qi, 2):div(Qi, 2, RoundUp), and allowed  values for the w index lie in 0:T-1.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.dipole_factor","page":"Library","title":"FastDipole.dipole_factor","text":"dipole_factor(struct_factor, lattice)\n\nApplies the neutron dipole factor, reducing the structure factor tensor to the  observable quantities. Specifically, performs the contraction:     ð’®(ðª Ï‰) = _Î±Î² (Î´_Î±Î² - ðª_Î± ðª_Î²) ð’®^Î±Î²(ðª Ï‰).\n\nstruct_factor should be of size 3 Ã— 3 Ã— Q1 Ã— â‹¯ Ã— QN Ã— T\n\nReturns a real array of size              Q1 Ã— â‹¯ Ã— QN Ã— T\n\n\n\n\n\n","category":"function"},{"location":"library/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"All plotting functions rely on a successful user installation of GLMakie, which is dependent on the correct video drivers being installed on your system. To ensure your installation is working correctly, please press ] in a Julia REPL to access the package manager, then execute test GLMakie.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"plot_lattice\nplot_spins\nplot_bonds\nplot_all_bonds\nanim_integration\nlive_integration\nlive_langevin_integration","category":"page"},{"location":"library/#FastDipole.plot_lattice","page":"Library","title":"FastDipole.plot_lattice","text":"plot_lattice(lattice; kwargs...)\n\nPlot a Lattice{2} or Lattice{3}. kwargs are passed to GLMakie.scatter!.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.plot_spins","page":"Library","title":"FastDipole.plot_spins","text":"plot_spins(sys::SpinSystem; linecolor=:grey, arrowcolor=:red, linewidth=0.1,\n                            arrowsize=0.3, arrowlength=1.0, kwargs...)\n\nPlot the spin configuration defined by sys. kwargs are passed to GLMakie.arrows.        \n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.plot_bonds","page":"Library","title":"FastDipole.plot_bonds","text":"plot_bonds(lattice, ints; bondwidth=4, kwargs...)\n\nPlot a list of pair interactions defined on a Lattice{2} or Lattice{3}. kwargs are passed to plot_lattice!.\n\n\n\n\n\nplot_bonds(sys::SpinSystem; kwargs...)\n\nPlot all pair interactions appearing in sys.hamiltonian, on the lattice defined by sys.lattice.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.plot_all_bonds","page":"Library","title":"FastDipole.plot_all_bonds","text":"plot_all_bonds(lattice::Lattice{3}, max_dist; kwargs...)\n\nPlot all bond equivalency classes present in lattice up to a maximum bond length of max_dist. kwargs are passed to plot_bonds.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.anim_integration","page":"Library","title":"FastDipole.anim_integration","text":"anim_integration(sys, fname, steps_per_frame, Î”t, nframes; kwargs...)\n\nProduce an animation of constant-energy Landau-Lifshitz dynamics of the given sys.\n\nArguments:\n\nsys::SpinSystem: The spin system to integrate.\nfname::String: The path to save the animation to.\nsteps_per_frame::Int: The number of integration steps to take per frame.\nÎ”t::Float64: The integration timestep size.\nnframes::Int: The number of frames to produce in the animation.\n\nOther keyword arguments are passed to GLMakie.arrows.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.live_integration","page":"Library","title":"FastDipole.live_integration","text":"live_integration(sys, steps_per_frame, Î”t; kwargs...)\n\nPerforms endless live constant-energy Landau-Lifshitz integration in an interactive window.\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.live_langevin_integration","page":"Library","title":"FastDipole.live_langevin_integration","text":"live_langevin_integration(sys, steps_per_frame, Î”t, kT; Î±=0.1, kwargs...)\n\nPerforms endless live Langevin Landau-Lifshitz integration in an interactive window.\n\n\n\n\n\n","category":"function"},{"location":"library/#Ewald-summation","page":"Library","title":"Ewald summation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"These functions are not intended to be used by typical users, who instead should utilize dipole interactions purely through DipoleReal and (preferably) DipoleFourier. However, developers may find the following documentation of the internals useful.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ewald_sum_monopole\newald_sum_dipole\nprecompute_monopole_ewald_compressed\nprecompute_dipole_ewald_compressed\ncontract_monopole_compressed\ncontract_dipole_compressed","category":"page"},{"location":"library/#FastDipole.ewald_sum_monopole","page":"Library","title":"FastDipole.ewald_sum_monopole","text":"ewald_sum_monopole(sys::ChargeSystem; Î·=1.0, extent=10)\n\nPerforms ewald summation to calculate the potential energy of a  system of monopoles with periodic boundary conditions.\n\nSpecifically, computes:\n\n    U = frac12 sum_ij q_i q_j left\n        sum_boldsymboln^ fracmathrmerfc(Î·boldsymbolr_ij\n            + boldsymboln)boldsymbolr_ij + boldsymboln\n      + frac4Ï€V sum_boldsymbolk ne 0 frace^-k^24Î·^2k^2\n            e^iboldsymbolkcdotboldsymbolr_ij right\n      - fracÏ€2VÎ·^2Q^2 - fracÎ·sqrtÏ€ sum_i q_i^2\n\n\n\n\n\n","category":"function"},{"location":"library/#FastDipole.ewald_sum_dipole","page":"Library","title":"FastDipole.ewald_sum_dipole","text":"ewald_sum_dipole(sys::SpinSystem; Î·=1.0, extent=10)\n\nPerforms ewald summation to calculate the potential energy of a  system of dipoles with periodic boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"library/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"These functions are not intended to be used by typical users, who instead should instead perform dynamics either using LangevinSampler or implicitly in Structure factor calculations. However, advanced users and developers may want direct access to an interface to perform dynamics integrations.","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"HeunP\nLangevinHeunP\nevolve!","category":"page"},{"location":"library/#FastDipole.HeunP","page":"Library","title":"FastDipole.HeunP","text":"Integrator for a 2nd-order energy-conserving Heun + projection scheme\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.LangevinHeunP","page":"Library","title":"FastDipole.LangevinHeunP","text":"Integrator implementing Langevin dynamics using a 2nd-order Heun + projection scheme\n\n\n\n\n\n","category":"type"},{"location":"library/#FastDipole.evolve!","page":"Library","title":"FastDipole.evolve!","text":"evolve!(integrator, Î”t)\n\nPerforms a single integrator timestep of size Î”t.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples stepped through here are available in examples/ as full loadable files containing executable functions. Specifically, we work through here the simulations performed in examples/reproduce_testcases.jl. All of the plotting code in here currently depends on an installation of Plots.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The high-level outline of performing a simulation is:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Create a Crystal, either by providing explicit geometry information  (Example 1), or by loading a .cif file (Example 2).\nUsing the Crystal, construct a Lattice which specifies the system  size, and a collection of Interactions assembled into a Hamiltonian.\nAssemble a SpinSystem using the newly created Lattice and Interactions.\nConstruct a sampler, either a LangevinSampler (Example 1), or a   MetropolisSampler (Example 2).\nUse the sampler directly to sample new states, or use it to perform Structure factor calculations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Defining interactions in step (2) can be aided by our utilities for symmetry analysis, demonstrated at the bottom of this page.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In all examples, we will assume that FastDipole and StaticArrays have been loaded:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FastDipole\nusing StaticArrays","category":"page"},{"location":"examples/#Example-1:-Diamond-lattice-with-antiferromagnetic-Heisenberg-interactions","page":"Examples","title":"Example 1: Diamond lattice with antiferromagnetic Heisenberg interactions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will step through the basic steps needed to set up and run a spin dynamics simulation, with finite-T statistics obtained by using Langevin dynamics. The full example is contained in the function test_diamond_heisenberg_sf() within examples/reproduce_testcases.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(1) We construct a diamond lattice by explicitly defining the lattice geometry. We will use the conventional cubic Bravais lattice with an 8-site basis. Our simulation box will be 8 times 8 times 8 unit cells along each axis. Since we're not thinking about a specific system, we label all of the sites with the arbitrary species label \"A\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"lat_vecs = [4.0 0.0 0.0;\n            0.0 4.0 0.0;\n            0.0 0.0 4.0]\nbasis_vecs = [\n    [0.0, 0.0, 0.0],\n    [0.0, 1/2, 1/2],\n    [1/2, 0.0, 1/2],\n    [1/2, 1/2, 0.0],\n    [3/4, 3/4, 3/4],\n    [3/4, 1/4, 1/4],\n    [1/4, 3/4, 1/4],\n    [1/4, 1/4, 3/4]\n]\nbasis_labels = fill(\"A\", 8)\nlatsize = [8, 8, 8]\nlattice = Lattice{3}(lat_vecs, basis_vecs, basis_labels, latsize)\ncrystal = Crystal(lattice)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, Lattice is a type which holds the geometry of our simulation box. This type can be indexed into as an array of size BÃ—LxÃ—LyÃ—Lz, with the first index selecting the sublattice and the remaining three selecting the unit cell, and the absolute position of the selected site will be given. For example, the following gives the position of the second sublattice site in the unit cell which is fifth along each axis: ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice[2, 5, 5, 5]\n3-element SVector{3, Float64} with indices SOneTo(3):\n 20.0\n 22.0\n 22.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(To save a minor amount of arithmetic, the bottom-left corner of the simulation box lives at a+b+c rather than 0). From this Lattice, we created a Crystal that infers extra information about the symmetries of the lattice and is needed to define interactions in our system later.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(2) In step 1, we ended up already creating our Lattice, so all that is left is to define our Heisenberg interactions. We want to set up nearest-neighbor antiferromagnetic interactions with a strength of J = 2828mathrmK. One nearest-neighbor bond is the one connecting basis site 3 with basis site 6 within a single unit cell. (We can figure this out using our tools for symmetry analysis, at the bottom of this page).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"J = 28.28           # Units of K\ninteractions = [\n    Heisenberg(J, crystal, Bond{3}(3, 6, SA[0,0,0])),\n]\nâ„‹ = Hamiltonian{3}(interactions)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, the 3 in both Bond{3} and Hamiltonian{3} indicates that they are defined in the context of a 3-dimensional system.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(3) Assembling a SpinSystem is straightforward. Then, we will randomize the system so that all spins are randomly placed on the unit sphere.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sys = SpinSystem(lattice, â„‹)\nrand!(sys)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The SpinSystem type is the central type used throughout our simulations. Internally, it contains the spin degrees of freedom which evolve during the simulation as well as the Hamiltonian defining how this evolution should occur. The type is indexable in the same way as Lattice, by providing a sublattice index alongside indices into the unit cell axes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sys[2, 5, 5, 5]\n3-element SVector{3, Float64} with indices SOneTo(3):\n  0.22787294226659\n  0.41462045511988654\n -0.8810015893169237","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we are obtaining the actual spin variable living at site (2, 5, 5, 5).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(4) We will simulate this system using Langevin dynamics, so we need to create a LangevinSampler. Note that the units of integration time and temperature are relative to the units implicitly used when setting up the interactions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Î”t = 0.02 / J       # Units of 1/K\nkT = 4.             # Units of K\nÎ±  = 0.1\nkB = 8.61733e-5     # Units of eV/K\nnsteps = 20000\nsampler = LangevinSampler(sys, kT, Î±, Î”t, nsteps)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"At this point we can call sample!(sampler) to produce new samples of the system, which will be reflected in the state of sysc. Instead, we will proceed to calculate the finite-T structure factor using our built-in routines.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(5) The full process of calculating a structure factor is handled by structure_factor. Internally, this function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Thermalizes the system for a while\nSamples a new thermal spin configuration\nPerforms constant-energy LL dynamics to obtain a Fourier-transformed  dynamics trajectory. Use this trajectory to calculate a structure  factor contribution S^alphabeta(boldsymbolq omega).\nRepeat steps (2,3), averaging structure factors across samples.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"See the documentation of structure_factor for details of how this process is controlled by the function arguments, and how to properly index into the resulting array.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will just look at the diagonal elements of this matrix along some cuts in reciprocal space. To improve statistics, we average these elements across the x y z spin directions since they are all symmetry equivalent in this model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"meas_rate = 10\nS = structure_factor(\n    sys, sampler; num_samples=5, dynÎ”t=Î”t, meas_rate=meas_rate,\n    num_freqs=1600, bz_size=(1,1,2), therm_samples=10, verbose=true\n)\n\n# Retain just the diagonal elements, which we will average across the\n#  symmetry-equivalent directions.\navgS = zeros(Float64, axes(S)[3:end])\nfor Î± in 1:3\n    @. avgS += real(S[Î±, Î±, :, :, :, :])\nend\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then plot some cuts using a function plot_many_cuts defined within the example script. (I.e. this code block will not successfully execute unless you include(\"examples/reproduce_testcases.jl)). We omit this code here as it's just a large amount of indexing and plotting code, but for details see the script.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the maximum Ï‰ present in our FFT\n# Need to scale by (S+1) with S=3/2 to match the reference,\n#  and then convert to meV.\nmaxÏ‰ = 1000 * 2Ï€ / ((meas_rate * Î”t) / kB) / (5/2)\np = plot_many_cuts(avgS; maxÏ‰=maxÏ‰, chopÏ‰=5.0)\ndisplay(p)","category":"page"},{"location":"examples/#Example-2:-FeI-with-a-complex-collection-of-interactions","page":"Examples","title":"Example 2: FeIâ‚‚ with a complex collection of interactions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we work through performing a more complicated and realistic simulation of FeIâ‚‚. While the number of interactions is much larger, the general process will be remarkably similar. We will also see how to perform sampling using Metropolis Monte Carlo through the MetropolisSampler type. The full example is contained in the function test_FeI2_MC() within examples/reproduce_testcases.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(1) As before, the first step is to make a Crystal. However, this time we will load the crystal directly from a common crystallographic file format called a .cif. You can download the structure file from this link. Then, we can load it as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cryst = Crystal(\"./FeI2.cif\")\ncryst = subcrystal(cryst, \"Fe2+\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Be sure to change \"./FeI2.cif\" to whatever filename you've locally saved the file as.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As only the Fe atoms are spinful, the second line here is selecting out just them. However, the subcrystal function critically retains information about the symmetry of the crystal structure with the I atoms present, which is important for symmetry-constraining allowed interactions between sites.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(2) We proceed to define our Hamiltonian similarly as before, however this time many more interactions are present. See the documentation on the Interactions for extended descriptions of each.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# All units in meV\nJ1mat = [-0.397  0      0    ;\n          0     -0.075 -0.261;\n          0     -0.261 -0.236]\nJ1 = GeneralCoupling(J1mat, cryst, Bond{3}(1, 1, [1, 0, 0]), \"J1\")\nJ2 = DiagonalCoupling([0.026, 0.026, 0.113], cryst, Bond{3}(1, 1, [1, -1, 0]), \"J2\")\nJ3 = DiagonalCoupling([0.166, 0.166, 0.211], cryst, Bond{3}(1, 1, [2, 0, 0]), \"J3\")\nJ0â€² = DiagonalCoupling([0.037, 0.037, -0.036], cryst, Bond{3}(1, 1, [0, 0, 1]), \"J0â€²\")\nJ1â€² = DiagonalCoupling([0.013, 0.013, 0.051], cryst, Bond{3}(1, 1, [1, 0, 1]), \"J1â€²\")\nJ2aâ€² = DiagonalCoupling([0.068, 0.068, 0.073], cryst, Bond{3}(1, 1, [1, -1, 1]), \"J2aâ€²\")\n\nD = OnSite([0.0, 0.0, -2.165/2], \"D\")\n\nâ„‹ = Hamiltonian{3}([J1, J2, J3, J0â€², J1â€², J2aâ€², D])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using our Crystal, we also need to generate a Lattice of some size to run our simulation on. In this example, we'll work with a modestly large system of size 16times 20times 4 along the (a b c) axes. We choose to make the a and b lengths different to artifically break a sixfold symmetry present in the system to help the Monte Carlo find the correct ground state later on.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"lattice = Lattice(cryst, (16, 20, 4))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To get better insight into the geometry and the long set of pair interactions we've defined above, we can take a look at both using the following plotting function (you may want to replace lattice with something smaller, say 5 times 5 times 3 to make the bonds easier to see, or adjust markersize to make the atoms easier to see):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot_bonds(lattice, â„‹; markersize=500)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(3) As with the previous example, the next step is to make a SpinSystem and randomize it:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"system = SpinSystem(lattice, â„‹)\nrand!(system)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(4) In this example, we'll choose to work with Metropolis Monte Carlo rather than Langevin sampling. This is necessary in this system due to a very strong on-site anisotropy (the OnSite term) making the spins nearly Ising-like. Continuous Langevin dyanmics can have ergodicity issues in these situations, so we have to turn back to the standard Metropolis randomized spin flip proposals.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"kB = 8.61733e-2  # Boltzmann constant, units of meV/K\nkT = 1.0 * kB    # Target simulation temp, in units of meV\n\nsampler = MetropolisSampler(system, kT, 1000)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"MetropolisSampler provides a very similar interface to LangevinSampler. Calling sample!(sampler) will perform some number of spin-flip proposals, then return with system updated to a new set of spin values. The 1000 in our constructor is asking the sampler to perform 1000 sweeps through the system before the sample! function should return.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(5) As in the previous example, we are going to end with computing a dynamic structure factor tensor using the structure_factor function. A heuristic for choosing a reasonable value of Î”t using in the Landau-Lifshitz dynamics is 0.01 divided by the largest energy scale present in the system. Here, that is the on-site anisotropy with a strength of 2.165/2 meV.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To make sure we don't do more work than really necessary, we set how often structure_factor internally stores snapshots (meas_rate) to target a maximum frequency of target_max_Ï‰. We also will only collect the structure factor along two Brillouin zones along the first reciprocal axis, by passing bz_size=(2,0,0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following block of code takes about five minutes on a test desktop, but if it's taking too long you can reduce the time either by reducing the number of sweeps MetropolisSampler does, or the num_samples or num_freqs in the structure factor computation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Î”t = 0.01 / (2.165/2)       # Units of 1/meV\n# Highest energy/frequency we actually care about resolving\ntarget_max_Ï‰ = 10.          # Units of meV\n# Interval number of steps of dynamics before collecting a snapshot for FFTs\nmeas_rate = convert(Int, div(2Ï€, (2 * target_max_Ï‰ * Î”t)))\n\nsampler = MetropolisSampler(system, kT, 500)\nprintln(\"Starting structure factor measurement...\")\nS = structure_factor(\n    system, sampler; num_samples=15, meas_rate=meas_rate,\n    num_freqs=1000, bz_size=(2,0,0), verbose=true, therm_samples=15\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Given the full complex-valued mathcalS^alpha beta(boldsymbolq omega), we can reduce it to the real-value experimentally-observable cross section by projection each \\mathcal{S}^{\\alpha \\beta} using the neutron dipole factor. See the dipole_factor documentation for more details. (To be truly comparable to experiment, a few more steps of processing need to be done which are currently unimplemented.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"S = dipole_factor(S, lattice)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Will add info here about plotting when better structure factor plotting functions are implemented.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following example, we'll take a closer look at how to make some more manual measurements of the system.","category":"page"},{"location":"examples/#Example-3:-Making-manual-measurements-within-a-Monte-Carlo-simulation","page":"Examples","title":"Example 3: Making manual measurements within a Monte Carlo simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will perform an extended Monte Carlo simulation of the same system as in the previous example, but will perform a careful thermal annealing down to low temperatures and measure an E(T) curve along the way. To do so, we will need to use the sampling tools a bit more manually.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As we're using the same system as before, the setup will be identical. The lines are copied below for convenience, but see the previous example for an explanation of each step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cryst = Crystal(\"./FeI2.cif\")\ncryst = subcrystal(cryst, \"Fe2+\")\n\n# All units in meV\nJ1mat = [-0.397  0      0    ;\n          0     -0.075 -0.261;\n          0     -0.261 -0.236]\nJ1 = GeneralCoupling(J1mat, cryst, Bond{3}(1, 1, [1, 0, 0]), \"J1\")\nJ2 = DiagonalCoupling([0.026, 0.026, 0.113], cryst, Bond{3}(1, 1, [1, -1, 0]), \"J2\")\nJ3 = DiagonalCoupling([0.166, 0.166, 0.211], cryst, Bond{3}(1, 1, [2, 0, 0]), \"J3\")\nJ0â€² = DiagonalCoupling([0.037, 0.037, -0.036], cryst, Bond{3}(1, 1, [0, 0, 1]), \"J0â€²\")\nJ1â€² = DiagonalCoupling([0.013, 0.013, 0.051], cryst, Bond{3}(1, 1, [1, 0, 1]), \"J1â€²\")\nJ2aâ€² = DiagonalCoupling([0.068, 0.068, 0.073], cryst, Bond{3}(1, 1, [1, -1, 1]), \"J2aâ€²\")\n\nD = OnSite([0.0, 0.0, -2.165/2], \"D\")\n\nâ„‹ = Hamiltonian{3}([J1, J2, J3, J0â€², J1â€², J2aâ€², D])\n\nlattice = Lattice(cryst, (16, 20, 4))\n\nsystem = SpinSystem(lattice, â„‹)\nrand!(system)\n\nsampler = MetropolisSampler(system, 1.0, 10)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, our goal in the following is to measure an entire E(T) curve, down to relatively low temperatures. To help the system find the ground state correctly at low temperatures, we will use the same system throughout and slowly \"anneal\" the temperature from the highest value down to the lowest.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These next few lines are pure Julia which simply sets up the temperatures we want to measure along, and initializes some Vector's to store some data during the simulations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"kB = 8.61733e-2             # Boltzmann constant, units of meV/K\n\n# Units of Kelvin, matching Xiaojian's range\ntemps = 10 .^ (range(log10(50), stop=0, length=50))\ntemps_meV = kB .* temps\nenergies = Float64[]\nenergy_errors = Float64[]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We've chosen to measure along a logarithmic temperature grid spanning T in 1 50, so that we pack the grid points tighter at lower temperatures where interesting things occur. energies and energy_errors are going to hold our measurements  of the mean energy and the errors at each temperature.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we're going to loop over these temperatures (moving from higher to lower temperatures). At each temperature, we're going to:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Set the temperature of the sampler to the new temperature using set_temp!.\nThermalize at the new temperature for a while before collecting  measurements using thermalize!.\nSample the system 1000 times, and measure the energy of each spin  configuration. We'll record all of these energies in temp_energies.\nCompute the mean energy and its standard error from our 1000 measurements\nPush this mean energy and standard error to our energies and   energy_errors vectors.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For simplicity, here we're just going to use the standard error across all energy measurements as the error. See the binned_statistics function in examples/reproduce_testcases.jl to see how to measure the error more carefully.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following block of code takes a few minutes to execute. Feel free to sample a sparser temperature grid, play around with some of the thermalization parameters, or perform fewer measurements to try to get it to execute faster.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Statistics\n\nfor (i, temp) in enumerate(temps_meV)\n    println(\"Temperature $i = $(temp)\")\n\n    temp_energies = Float64[]\n    set_temp!(sampler, temp)\n    thermalize!(sampler, 100)\n    for _ in 1:1000\n        sample!(sampler) \n        push!(temp_energies, energy(sampler))\n    end\n    meanE = mean(temp_energies)\n    errE  = std(temp_energies) / sqrt(length(temp_energies))\n    push!(energies, meanE)\n    push!(energy_errors, errE)\nend\n\n# Convert energies into energy / spin, in units of K\nenergies ./= (length(system) * kB)\nenergy_errors ./= (length(system) * kB)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we can plot what we've gotten! If you have the Plots.jl library installed you can do this as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\n\np = plot(temps, energies, yerror=energy_errors, marker=:true, ms=3, label=\"Monte Carlo Results\")\nxlabel!(L\"$T$ [K]\")\nylabel!(L\"$E$ [K]\")\np","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If all has gone well, you should get a plot that looks something like the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: FeIâ‚‚ Energy Curve)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can take a look at the final low-energy spin configuration by:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot_spins(system; arrowsize=1.5, arrowlength=3, linewidth=0.5)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You should see antiferromagnetic stripes within each c-plane, which shift by one lattice site as you move up each plane!","category":"page"},{"location":"examples/#Symmetry-analysis","page":"Examples","title":"Symmetry analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"When defining pair interactions, we are always defining the interactions on entire symmetry classes at the same time. To do this, we need to provide the exchange matrix J on a specific reference Bond, which is then automatically propagated to all symmetry-equivalent bonds. However, on any given bond, the exchange matrix must live within a restricted space of 3 times 3 matrices that is confined by the symmetry properties of the underlying crystal.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discover all symmetry classes of bonds up to a certain distance while simultaneously learning what the allowed form of the J matrix is, construct a Crystal then call the function print_bond_table.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice = FastDipole.diamond_conventional(1.0, (8, 8, 8))\njulia> crystal = Crystal(lattice)\njulia> print_bond_table(crystal, 4.0)\n\nBond{3}(1, 1, [0, 0, 0])\nDistance 0, multiplicity 1\nConnects [0, 0, 0] to [0, 0, 0]\nAllowed coupling:  |A 0 0 |\n                   |0 A 0 |\n                   |0 0 A |\n\nBond{3}(3, 6, [0, 0, 0])\nDistance 1.732, multiplicity 4\nConnects [0.5, 0, 0.5] to [0.75, 0.25, 0.25]\nAllowed coupling:  | A  B -B |\n                   | B  A -B |\n                   |-B -B  A |\n\nBond{3}(1, 2, [0, 0, 0])\nDistance 2.828, multiplicity 12\nConnects [0, 0, 0] to [0, 0.5, 0.5]\nAllowed coupling:  | B  D  D |\n                   |-D  C  A |\n                   |-D  A  C |\n\nBond{3}(1, 6, [0, 0, 0])\nDistance 3.317, multiplicity 12\nConnects [0, 0, 0] to [0.75, 0.25, 0.25]\nAllowed coupling:  |B C C |\n                   |C D A |\n                   |C A D |\n\nBond{3}(1, 1, [1, 0, 0])\nDistance 4, multiplicity 6\nConnects [0, 0, 0] to [1, 0, 0]\nAllowed coupling:  |A 0 0 |\n                   |0 B 0 |\n                   |0 0 B |","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Each block represents one symmetry equivalence class of bonds, along with a single representative (\"canonical\") Bond for that class and the allowed exchange coupling matrix on that canonical bond.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can also query what the allowed exchange matrix is on a specific bond using allowed_J.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> allowed_J(crystal, Bond{3}(1, 5, [1,-1,0]))\n\n3Ã—3 Matrix{String}:\n \"D\"  \"A\"  \"B\"\n \"A\"  \"E\"  \"C\"\n \"B\"  \"C\"  \"F\"","category":"page"},{"location":"#FastDipole.jl","page":"FastDipole.jl","title":"FastDipole.jl","text":"","category":"section"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"This is the documentation for FastDipole.jl (final name to be decided). This package aims to be a general-purpose library for simulating and analyzing classical spin systems obtained as the mathrmSU(N) classical limit of quantum spin Hamiltonians.","category":"page"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"Current Features","category":"page"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"mathrmSU(2) Landau-Lifshitz spin dynamics\nDefine arbitrary spin Hamiltonians involving supported interactions:\nExternal fields\nArbitrary generalized pair interactions\nOn-site anisotropies\nLong-range dipole-dipole interactions\nAccelerated dipole-dipole interactions using Ewald summation and Fourier-space evaluation\nFinite-T sampling using either Langevin dynamics or Metropolis Monte Carlo\nStructure factor calculations\nAutomated symmetry analysis and bond equivalency class discovery\nInteractive plotting using Makie.jl","category":"page"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"Planned Features","category":"page"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"CPU parallelization of dynamics and Monte Carlo simulations\nParallel tempering\nGeneralized mathrmSU(N) models\nGPU acceleration\nAccelerated local MC updates in the presence of long-rage dipole interactions","category":"page"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"To start running your first simulations, head over to Getting Started to install the package. Then, see Examples for a set of examples demonstrating various features.","category":"page"},{"location":"","page":"FastDipole.jl","title":"FastDipole.jl","text":"Or, take a look at the full Library documentation.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"To be written.","category":"page"}]
}
